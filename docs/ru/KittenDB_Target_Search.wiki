Существуют три вида поисковых запросов --- собственно ''search'' для поиска по людям, и ''prices'' c ''target'' для объявлений.

Запрос ''target'' имеет вид <code>target{$ad_id}_{$ad_сost_per_click}[{$discount}]({$query})</code>, где <code>$query</code> обладает тем же синтаксисом что и в поисковом запросе.
<br>
Выдает количество людей, на которых объявление с данными критериями будет таргетированно, и таргетирует на них объявление. Это означает, что в список возвращаемый функцией <code> get("user_ads{$id}")</code> для этих юзеров добавится данное объявление. Строка $discount, если присутствует, имеет вид <tt>-{$disc_perc}%</tt>, где $disc_perc -- скидка в процентах (например, <tt>-35%</tt>), допустимые значения от 0% до 89%. Фактически приводит к установке учетного сомножителя в значение 1-$disc_perc/100, см. также ad_setfactor. Если параметр $discount отсутствует, то текущее значение учетного сомножителя не изменяется; если оно еще не было задано, используется 1.0.

Запрос ''prices'' имеет вид <code>prices{$place}[_{$and_mask}:{$xor_mask}]($query#{$quantity})</code>, где <code>$query</code> обладает тем же синтаксисом, что и в поисковом запросе, а {$quantity} - количество интересующих нас результатов. Поля $and_mask и $xor_mask, если есть, ограничивают сканируемые объявления теми из них, у которых (ad.sites_mask ^ xor_mask) & and_mask = 0. По умолчанию используется <tt>254:0</tt>.

Возвращается массив (перечисленный через запятую); нулевой элемент - количество людей, удовлетворяющих запросу <code>$query</code>, а  i-й - количество людей, удовлетворяющих этому запросу так что для них объявление будет не ниже <code>$place</code> места, при cpv в диапазоне от (i-1) * 0.0002  до i * 0.0002, и i принимает значения от 1 до <code>$quantity</code>. В $place можно добавлять также флаги: добавление флага 1024 - означает использование нового алгоритма.

Запрос ''ad_pricing'' является аналогом ''prices'', но работает по пользователям, на которых старгетировано конкретное активное или недавно выключенное объявление. Его формат: <code>ad_pricing{$place}_{$ad_id}[_{$and_mask}:{$xor_mask}][,{$max_users_per_server}]#{$quantity}</code>. Параметры $place и $quantity имеют тот же смысл, что и для запроса prices, параметр $max_users_per_server ограничивает сверху количество сканируемых пользователей на сервер (если их реально больше, то выбирается случайное подмножество из $max_users_per_server пользователей). Значение по умолчанию - 50. Флаг 1024 в этом запросе тоже допустим.

Запрос ''targ_audience'' определяет аудиторию объявления. А именно, <code>targ_audience{$place}_{$cpv}[_{$and_mask}:{$xor_mask}][#{$max_users_per_server}]($aux_query_1;...;$aux_query_K;$query)</code> сканирует до $max_users_per_server пользователей, для которых выполнено $query и в списке объявлений которых на месте $place находится объявление с cpv не выше переданного (cpv - это целое число, имеющее тот же смысл, что и i в ''prices''). Возвращается вектор из 3K+3 целых чисел. Первые три числа - это общее количество пользователей, соответствующих условию $query; количество просканированных пользователей; количество просканированных пользователей, для которых объявление с такой ценой будет стоять не ниже, чем на месте {$place}. Далее следует K троек чисел, а именно, для каждого очередного дополнительного условия $aux_query_i возвращается тройка, аналогичная первой тройке чисел, но для условия ($query & $aux_query_i).

Запрос ''audience'' определяет аудиторию объявления. А именно, <code>audience($aux_query_1;...;$aux_query_K;$query)</code> сканирует пользователей, для которых выполнено $query и вычисляет, для какого количества из них выполнено каждое из дополнительных условий $aux_query_K . Возвращается вектор из K+1 целого числа: первое число - это общее количество пользователей, соответствующих условию $query, далее идет количество тех из них, для которых выполнено дополнительное условие $aux_query_1, затем то же самое для $aux_query_2 и т.д.

В том случае, если строка поискового запроса или запросов длинная, можно сделать <code>set("temp{$tag}", "$aux_query_1;...;$aux_query_K")</code> и сослаться на сохраненный список в следующем запросе с помощью <code>targ_audience{$place}_{$cpv}[#{$max_users_per_server}]($tag;$query)</code>, где $tag - случайное число от 1 до 10<sup>9</sup>. Фактически этот список вставляется в то самое место запроса, где упоминается его номер $tag. При этом в сохраненных через <code>set temp{$tag}</code> списках запросов в качестве разделителя можно использовать не только <tt>;</tt>, но и перевод строки <tt>\n</tt>.

Кроме того, в поисковые запросы, отличные от target, можно передавать дополнительный список пользователей, сделав непосредственно перед запросом <code>set("xtemp{$tag}", $user_list)</code>, где {$tag} - ''отрицательное'' число от -10<sup>9</sup> до -1, $userlist - список id пользователей, переданный либо в виде строки, составленной из разделенных запятыми десятичных записей натуральных чисел (id), либо в виде строки из 4N+4 байтов, начинающейся с подстроки '0000' и далее содержащей N идентификаторов пользователей типа int в двоичном виде. После этого в последующем поисковом запросе можно ссылаться на переданный список с помощью предиката ''in_list''. Пример: <code>get search#R10(in_list&sex=1)</code>.

Формат поискового запроса:
<br>
<code>get("search{$extra}({$query})")</code>

Особый случай: <code>search(one)</code> вернет количество движков, на которые раскидывается запрос.

Максимальная длина поискового запроса - 950 символов!

=== Формат поля $extra  ===

Поле <code>$extra</code> показывает, как сортировать результаты поиска, и сколько их выдать. 
<br>
Синтаксис:
<br>
поле имеет вид 
<br>
<code>#[<Тип сортировки> | ""][<модификатор типа сортировки> | ""][<Количество объектов, которые нужно вернуть> | ""] </code>
<br>
&lt;Тип сортировки&gt; =&gt; i|I|r|R
<br>
&lt;Модификатор типа сортировки&gt; =&gt; %

значения:
*i -  по возрастанию user_id
*I - по убыванию user_id
*r - по возрастанию рейтинга
*R - по убыванию рейтинга

*% - результаты в двоичном виде.

=== Формат поля $query  ===
$query состоит из нескольких параметров по которым ведется поиск. Они бывают строковые, числовые и составные. Поддерживаются скобки и операции '&'(and) '|'(or) и '!'(not).

неформально говоря: 
<br>
term ::= "parameter_name" ( '=' | '&gt;=' | '&lt;=' ) "value" | '(' expr ')' | '!' term | 'true' | 'false'
<br>
expr ::= term { ( '&' | '|' ) term} 
<br>
complex_term ::= "complex_parameter_name" '.(' expr ')' | '(' complex_expr ')' | '!' complex_term 
<br>
complex_expr ::= (term | complex_term) { ( '&' | '|' ) (term | complex_term} 
<br>
$key ::= '('complex_expr')'

Приоритет логических операций стандартный.

Пример поискового запроса: <code>search#R1000((city=282&education.(chair=14012&graduation=2010)&has_photo=1&military.(start=2009)&(operator=86)))</code> 

К сожалению это не все условия на поисковый ключ - у каждого составного параметра есть прописаный в коде список допустимых подпараметров; не на всех простых параметрах введено отношение порядка(сравнения '&lt;='/'&gt;=')

===Составные параметры===
{|
|-
! Параметр !! подпараметры
|-
| company || name, job
|-
| group || type, id
|-                   
| military || unit, start, finish
|-                   
| address || country, city, district, station, street, type, house, name
|-                   
| school || country, city, id, graduation, class, spec
|-                   
| education || form, status, country, city, university, graduation, faculty, chair
|-
| lang || id
|}

<b>подпараметры с одинаковым названием не имеют между собой ничего общего, если их родительские типы различны</b>

{|
|-
! Параметр !! Минимальное значение !! Максимальное значение !! Допустимы ли '&lt;='/'&gt;='
|-
| id || 1 || 2*10^9 || да
|-
| country || 1 || 255 || нет
|-
| city || 1 || - || нет
|-
| bday_day || 1 || 31 || да
|-
| bday_month || 1 || 12 || да
|-
| bday_year || 1900 || 2017 || да
|-
| timezone (от Москвы, в минутах) || -1439 || 1439 || да
|-
| political || 0 || 8 || нет
|-
| sex || 0 || 2 || нет
|-
| operator (сотовый) || 0 || 10000 || нет
|-
| status (женат/разведен etc.)|| 0 || 7 || нет
|-
| region || 0 || 10<sup>7</sup> || нет
|-
| browser || 0 || 250 || нет
|-
| height || 0 || 255 || да
|-
| smoking || 0 || 5 || нет
|-
| alcohol || 0 || 5 || нет
|-
| personal_priority || 0 || 10 || нет
|-
| important_in_others || 0 || 10 || нет
|-
| hidden || 0 || 3 || да
|-
| countries_visited || 0 || 250 || нет
|-
| school:id || 1 || - || нет
|-
| school:grad || 1900 || 2033 || да
|-
| school:class || 1 || 96 || нет
|-
| school:spec || - || - || строковый
|-
| address:district || 1 || - || нет
|-
| address:station || 1 || - || нет
|-
| address:street || 1 || - || нет
|-
| address:type || 1 || - || нет
|-
| address:house || - || - || строковый
|-
| address:name || - || - || строковый
|-
| group:type || 1 || 127 || нет
|-
| group:id || -4*10<sup>6</sup> || 32*10<sup>6</sup> || нет
|-
| lang:id || 0 || 1024 || нет
|-
| company:name || - || - || строковый
|-
| company:job || - || - || строковый
|-
| military:unit || 1 || -1 || нет
|-
| military:start || 1900 || 2033 || да
|-
| military:finish || 1900 || 2033 || да
|-
| education:form || 0 || 3 || нет
|-
| education:status || 0 || 6 || нет
|-
| education:university || 1 || - || нет
|-
| education:faculty || 1 || - || нет
|-
| education:chair || 1 || - || нет
|-
| education:graduation || 1900 || 2033 || да
|-
| name || - || - || строковый
|-
| interests || - || - || строковый
|-
| religion || - || - || строковый
|-
| hometown || - || - || строковый
|-
| proposal || - || - || строковый    
|-
| name_interests || - || - || строковый    
|-
| online || 0 || 0x7fffffff || да
|-
| has_photo || 0 || 1 || нет
|-
| uses_apps || 0 || 1 || нет
|-
| pays_money || 0 || 1 || нет
|-
| privacy || 0 || 10 || нет
|-
| random || 0 || 1000 || да
|-
| true || - || - || нет (флаг)
|-
| false || - || - || нет (флаг)
|-
| birthday_today || - || - || нет (флаг)
|-
| birthday_tomorrow || - || - || нет (флаг)
|-
| birthday_soon || 0 || 7 || нет
|-
| age || 0 || 100 || да
|-
| future_age || 0 || 100 || да
|-
| gcountry || 0 || 255 || нет
|-
| custom1..15 || 0 || 255 || да
|-
| in_list || - || - || нет (флаг)
|-
|}

Все строковые типы принимают значение, состоящее из не более чем восьми слов (alphanumeric; каждое слово - не больше 127 символов). Большинство целочисленных параметров по умолчанию равны 0.

Смысл большинства параметров понятен из названия; name_interests позволяет искать и в имени и в интересах; в поле online хранится время (unixtime) последнего захода; в поле random не хранится ничего, оно используется для отсечек вида "random &lt; 42" в таргетинге. Рандом берется каждый раз независимо, максимальное значение - 1000. Запрос  <code>"target({$query}&(random<=41)&(random<=239))"</code> будет означать, что объявление будет старгетировано на долю (42/1000) * (240/1000) от тех, кто подходит под запрос <code>$query</code>. Подпараметры вида university:country могут принимать те же значения, что и базовые параметры с таким названием, и в этой таблице опущены.
