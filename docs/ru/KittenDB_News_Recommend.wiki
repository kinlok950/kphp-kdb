==Движок рекомендация новостей==

Предназначен для рекомендаций новостей по принципу: если много моих друзей как-то взаимодействуют с этим объектом - значит и я наверняка захочу с ним ознакомиться.

==Список доступных функций==
===Добавление обновления===

<code>$MC_News->set("recommend_update{$id}", "$type,$owner,$place,$action,$item,$time", 0, 600);</code>

Добавляет новое действие пользователя $id.

Параметр - строка, состоящая из 5 чисел, имеющих следующий смысл: 
{|
|-
| type || тип объекта, к которому относится действие || 1..31
|-
| owner || владелец объекта, к которому относится действие; имеет смысл в паре с place и/или item || int32
|-
| place || место, в котором было совершено действие (например, id фотографии, поста или видео) || int32
|-
| action || совершённое действие. имеет смысл в паре с place_type || 1..255
|-
| item || объект, ставший результатом совершения действия (например id комментария, user_id для случая отметок "Мне нравится", id поста, если это был репост и т д) || int32
|-
| time || дата создания объекта || int32
|}

Смысл поля type: 
{|
|-
! type !! Тип объекта
|-
| 1 || Пост на стене
|-
| 2 || Фотография
|-
| 3 || Альбом (чтобы можно было суммировать кучу разрозненных)
|-
| 4 || Видеозапись
|-
| 5 || Заметка
|-
| 6 || Внешняя страница (предпросмотр)
|-
| 7 || Внешняя страница через API (виджеты)
|}

Смысл поля action: 
{|
|-
! type !! action !! Смысл !! Ценность ($rate)
|-
| * || 1 || Мне нравится || 1.0
|-
| * || 2 || Репост || 3.0
|-
| * || 3 || Комментарий || 3.0
|}

===Изменение ценности действия===
<code>$MC_News->set("recommend_rate{$type},{$action}", "{$rate}", 0, 600);</code>
<br>
mc-proxy рассылает такой запрос диагонально (пересылает всем движкам).
<br>
По умолчанию, ценность действие равна 1.0.

===Получение ценности действия===
<code>$MC_News->get("{$N}@recommend_rate{$type},{$action}");</code>

=== Передача большого списка пользователей ===
<code>set("urlist$list_tag", $list, 0, 600);</code>
<br>
Запоминает список пользователей, идентифицируемый ''отрицательным'' случайным числом $list_tag. Параметр $list есть список "{$user_id}_{$user_rate}", перечисленных через запятую. Кроме того, если $list начинается со строки <tt>0001</tt>, остаток разбивается на группы по 8 байт, каждая из которых интерпретируется как представление двух 32-битных чисел - user_id и user_rate.
<br>
С помощью отрицательных рейтингов пользователей, можно передавать список обязательных владельцев и список запрещенных владельцев.
<br>
"{$owner}_-2" означает, что $owner - обязательный владелец.
<br>
"{$owner}_-1" означает, что $owner - запрещенный владелец.
<br>
Желательно, чтобы эти списки не были слишком большими, так как mc-proxy-search будет пересылать их '''каждому''' движку. С другой стороны, списки владельцев уменьшают трафик возвращаемый движками mc-proxy-search.
<br>
Если список обязательных владельцев не пуст, то owner объекта должен быть из этого списка.
<br>
Если owner объекта находится в списке запрещенных владельцев, то действие игнорируется.
<br>
Движок сам удаляет одинаковые $user_id с положительным рейтингом, а потом сортирует их в порядке убывания рейтинга.

Сразу после этого запроса должен следовать запрос вида <tt>get("recommend_updates...")</tt>, ссылающийся на только что переданный список по значению $list_tag.

===Получение обновлений===
get("recommend_updates{$type_mask}_{$date},{$enddate}_{$id}_{$T}:{$user_list}");
<br>
get("recommend_updates{$type_mask}_{$date},{$enddate}_{$id}_{$T}>{$timestamp}:{$user_list}");
<br>
get("recommend_updates{$type_mask}_{$date},{$enddate}_{$id}_{$T}>{$timestamp}#{$limit}:{$user_list}");
<br>
get("recommend_updates{$type_mask}_{$date},{$enddate}_{$id}_{$T}>{$timestamp}#{$limit}@{$acting_users_limit}:{$user_list}");
<br>
Получает список рекомендаций объектов.

Параметры type_mask, data, enddate выполняют те же роли, что и в [[KittenDB_Newsfeed.wiki|KittenDB_Newsfeed]].
<br>
Параметр $user_list представляет из себя набор чисел, разделённых запятыми: "$uid1_$rate1,$uid2_$rate2,..",
где $uidN, $rateN - целые числа. $rateN задаёт значимость действий пользоваля с $uidN.
<br>
$T задает период полураспада в секундах.
<br>
$acting_users_limit задает минимальное количество уникальных друзей, совершивших действие по отношению к объекту.
<br>
"&gt;$timestamp" ограничивает по item_creation_time снизу.
<br>
"&lt;$timestamp" ограничивает по item_creation_time сверху.

Результат должен быть возвращён в следующем виде:
<br>
$N,$type_1,$owner_1,$place_1,$type_2,$owner_2,$place_2,...,$type_N,$owner_N,$place_N

===Получение обновлений в "сыром" виде===
<code>get("raw_recommend_updates{$type_mask}_{$st_time},{$end_time}_{$id}_{$t}_{$timestamp}:{$user_list}")</code>
<br>
Возвращает список обновлений для данного пользователя или списка пользователей в сыром виде: массив из 6N+1 чисел, первое число - N, количество возвращаемых записей, затем каждое обновление задается с помощью шести чисел: $type,$owner,$place,$acting_users,$weight (double - 2 int).
<br>
Если название ключа начинается cимволом %, результат будет возвращен в двоичном виде как последовательность из 20N байтов. 

Движок не возвращает обновления c item созданным более (30*$t) секунд назад. Действия с одинаковыми (user_id, type, owner, place, action), во второй раз не учитываются.

===Последовательность действий для получения списка рекомендаций===
# Получаем все действия всех $uid{1-N} по отношению к объектам соотвествующих $type_mask типов
# Отбрасываем все действия по отношению к объектам с owner_id = $id. Если передан параметр $timestamp, то объекты с датой создания раньше чем timestamp тоже не учитываем.
# Выполняем группировку действий по $type+$owner+$place, при этом ведем счетчик $weight, куда суммируем все произведения $action_rate*$uid_rate
# Выполняем сортировку по $weight c учетом периода полураспада $T и время создания объекта.

===Коэффициенты при реальном использовании===
При таком принципе сбора рекомендаций важно, чтобы в топе не были постоянно старые объекты с кучей новых лайков. Для этого необходимо ввести в расчеты возраст объекта и при сортировке его учитывать.
<br>
$T определяет влияние возраста объекта, на позицию объекта в выдаче. Чем $T меньше, тем более значим небольшой возраст по сравнению с рейтингом (отметками, комментариями).

Подобрав хорошие коэффициенты (они могут различаться в зависимости, например, от общего количества друзей), можно добиться довольно адекватной выдачи.
