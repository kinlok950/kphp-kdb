==Storage engine==
Движок для хранения фотографий, документов и пр. 
<br>
Одному тому обычно соответствуют два бинлога '''storage-engine''', расположенные на разных дисках. 
<br>
У каждого тома есть идентификатор '''volume_id'''. 
<br>
Один экземляр '''storage-engine''' работает со всеми 1000 томами. 
<br>
В момент запуска '''storage-engine''' указывают 4 директории, в которых содержатся бинлоги. 
<br>
'''storage-engine''' сканирует эти директории и выбирает для каждого тома '''главный''' и '''дополнительный бинлог'''. 
<br>
Если '''volume_id''' четный, то '''главный''' бинлог берется из директории с меньшим номером, 
а если '''volume_id''' нечетный, то из директории с большим номером. 
<br>
Пока нет ошибок чтения с диска при загрузке заголовка документа из '''главного''' бинлога, '''storage-engine''' будет его использовать при каждом http запросе для заданного тома. 

===Проверка возможности сохранения документа===
<blockquote><code>
$r = get("check_file{$volume_id},{$size_in_bytes},{$max_disk_used_space_percent}"); 
</code></blockquote>
Проверяет папки на наличие свободного места, бинлоги и т.д. для сохранения файла указанного размера, возвращает '1', '0' или false.
<br>
Если хотя бы один файл бинлога не открыт для записи возвращает '0'.
<br>
{$max_disk_used_space_percent} - опциональный вещественный параметр по умолчанию равный 99. Т.е. считается, что забитый на 99% диск - полный.  Не рекомендуется присваивать ему 100, так как для сокращения количества системных вызовов '''statvfs''', '''storage-engine''' применяет эвристику, что скорость записи на диск не превышает 200M в cекунду.

===Адресация документа по user_id, album_id, local_id===
Поскольку фотография обычно получается как результат работы '''image-engine''', '''storage-engine''' умеет добавлять только локальные файлы. 

<pre>
$r = get ("file{$volume_id},{$path}"); 
if ($r !== false) { 
  $a = explode (",", $r); 
  $secret = $a[0]; 
  $local_id = $a[1]; 
} 
</pre>

$secret возвращается в кодировке (RFC 4648 'base64url' encoding, cмотреть страницу Base64 википедии), $local_id - в шестнадцатеричной системе счисления. 

Документ скачивается по http протоколу по ссылке: 
<br>
"/v{$volume_id}/{$local_id}/{$secret}.{$ext}" 

===Спрятать/вернуть файл===
<blockquote><code>
$r = get ("hide{$volume_id},{$local_id_hex}"); 
</code></blockquote>
После выполнения, этой команды storage-engine будет возвращать однопиксельное прозрачный png файл, вместо указанного изображения. Чтобы отменить, команду ее нужно вызвать повторно. 
<blockquote><code>
$r = get ("valid{$volume_id},{$local_id_hex},{$secret}")
</code></blockquote>
Возвращает '0', если файл был спрятан и '1' в противном случае. В PHP возвращается false, если указанного тома не существует.

===Адресация документа по md5===
get возвращает "{$secret},{$md5_in_base64url}". 
<br>
Документ скачивается по http протоколу по ссылке: 
<br>
"/v{$volume_id}/{$md5_in_base64url}/{$secret}.{$ext}". 
<br>
Отличия кодировки base64url от base64: 
* все символы '+' заменяются на '-' (минус) 
* все символы '/' заменяются на '_' (подчеркивание) 
* все заключительные символы '=' обрезаются 

{|
|-
| $volume_id
| 64-битное целое (dec)
|-
| $secret
| 64-битное целое (base64url)
|-
| $local_id
| 32-битное целое (hex)
|-
| $md5
| 128-битное целое (base64url)
|} 

===Работа с томами по memcache протоколу===
get("volumes"); 
<br>
Возвращает строку, в которой через запятую указаны volume_id томов, с которыми работает экземпляр storage-engine. 
<br>
 $a = get("volume{$volume_id}"); 
<br>
Возвращает ассоциативный массив со статистикой для заданного тома. 
<br>
Младший бит mode - файл открыт для чтения, 2 бит mode - файл открыт для записи. 
<br>
 $a = get("Volume{$volume_id}"); 
<br>
Возвращает статистику для заданного тома в ''tab-separated'' формате . 
<br>
 $a = get("dirs"); 
<br>
Возвращает в массиве статистику по директориям 
<br>
 $a = get("disable_file{$volume_id},{$dir_id}"); 
<br>
if ($a == "1") { 
<br>
  //файл бинлога был успешно заблокирован 
<br>
} else if ($a === false) { 
<br>
  $r = get("Volume{$volume_id}"); 
<br>
  if ($r !== false) { 
<br>
    //проверить mode на равенство 0 у соответствующего файла бинлога 
<br>
  } 
<br>
} 
<br>
 $a = get("enable_file{$volume_id},{$dir_id}"); 
<br>
Просит storage-engine переоткрыть файл после его починки. 
* Возвращает "1" в случае успеха. 
* Возвращает "0" в случае не успеха. 
* Возвращает "2" в случае, если размер тома не совпал с размером файла (storage-engine что-то уже успел записать). 

===Пересканирование каталога===
Если '''storage-engine''' был запущен, когда какой-то директории не существуeт (например, сразу после замены диска), то, когда директория будет создана и в неё будут скопированы бинлоги, '''storage-engine''' можно попросить пересканировать её заново запросом «scandir'''$path'''». 

Команду «scandir» можно успешно вызвать только один раз (в статистике директории есть поле «scanned», если в нём стоит «1», то команда будет проигнорирована). 

В случае успеха возвращается «0», в случае неудачи — отрицательное число (код ошибки) или строка с описанием ошибки. Во время пересканирования '''storage-engine''' не открывает найденные бинлоги для чтения и для записи, поэтому бинлоги потом нужно включать с помощью команды «enable_file». 

===Создание пустых бинлогов===
$./storage-engine -E1000,'''cs_number''',0,photo 
<br>
Создаст 1000 бинлогов (photo000.bin, photo001.bin, ). 
* адресация документов по user_id, local_id. 
* photo000.bin (volume_id = '''cs_number''' * 1000), photo001.bin (volume_id = '''cs_number''' * 1000 + 1), и т.д. 

===Восстановление бинлогов===
Если у одного тома длины бинлогов не совпадают, то более короткий может быть исправлен с помощью утилиты '''storage-append'''. 
<br>
Эта утилита дописывает в выходной бинлог из входного бинлога документы, исправляя при необходимости ошибки 1 бита. 

Если файл тома побился (не читается) в середине, то  запуск storage-append с ключом -m восстанавливает изображения, которые можно восстановить и вставляет 1x1 белый jpeg с нулевым cекретом  (AAAAAAAAAAA) вместо побитых изображений. Выходной файл не должен существовать, а входной должен читаться. Входной файл - конкатенация (cat) читаемых кусков бинлога. Все куски должны быть из кратного 4 числа байт и их начала тоже должны быть выравнены по 4 байтам.
'''После успешного восстановления в этом режиме необходимо удалить старые снимки'''. Так как они содержат неадекватные смещения.

===NGINX===

====nginx install====
./configure --add-module=/path_to_kittendb_source_tree/src/storage 
make install 

====nginx.conf====
<pre>
location ~ "^/v[0-9]{1,18}/[0-9a-f]{1,8}/[A-Za-z0-9_-]{11}\.(jpg|png|gif)$" { 
  proxy_pass [http://127.0.0.1:8081]; 
  proxy_redirect off; 
} 
location ~ "^/[A-Za-z0-9_./]+:[a-f0-9]{1,16}:[A-Za-z0-9_-]{11}:[a-f0-9]{1,8}$" { 
  storage; 
  internal; 
  expires max; 
} 
</pre>

===Распространенные ошибки жёстких дисков===
* закончилось место на диске 
* отвалился весь диск (чтение и fsync зависает на минуту, что может привести к пределу количества aio запросов) 
* побился сектор 
* изменился 1 бит 

==RPC-протокол==

Storage-engine опционально поддерживает две основные операции (добавление нового файла и получение файла по volume_id+local_id+secret через RPC-протокол. Если эта опция включена, он может частично или полностью отказаться от поддержки http. 

