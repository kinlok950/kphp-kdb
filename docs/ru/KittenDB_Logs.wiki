KittenDB Logs предназначен для логирования каких-либо событий, их обработки и
быстрого доступа к ним. На основе хранимой информации движок умеет отвечать
на самые разнообразные запросы, для которых используется близкий к SQL
синтаксис.

==Интерфейс==
Движок поддерживает memcached интерфейс.

==Общая структура==
Все хранимые данные пользователей будут называться событиями. Информация обо
всех событиях должна передаваться движку. У каждого события есть обязательные/
индексные поля. Для базового кластера набор обязательных полей следующий:
<br>
0. <code>time</code> - время, в которое произошло событие, автоматически
присваивается движком - целое положительное 31-битное число, int.
<br>
1. <code>type</code> - тип события - целое положительное 15-битное число, int.
<br>
2. <code>uid</code> - id пользователя, совершившего действие, - знаковое
32-битное целое, int.
<br>
3. <code>some_long_field</code> - знаковое 64-битное целое, long.

Все остальные поля опциональны и могут различаться у событий разных типов.
Названия базовых полей можно изменять произвольным образом параметрами движка.
Изменение набора базовых полей достигается на данный момент исключительно
редактированием исходного кода движка. Суммарный размер базовых полей в
32-битных словах задаётся при помощи константы FN в logs/kdb-logs-binlog.h.
Сама структура базовых полей, их названия по умолчанию и типы описываются в
logs-data.c в переменных
<br>
int std_t[FN + 4];
<br>
и
<br>
char *field_names[FN];
<br>
Первые два поля должны быть time и type. Базовые поля могут быть только типов
int и long (см. ниже).


==Поддерживаемые типы полей==
{|
|+ Поддерживаемые типы
|-
! Название !! Категории !! Диапазон !! Описание
|-
| int || Целочисленный, числовой || -2147483648 .. 2147483647 || Базовый целочисленный тип
|-
| long || Целочисленный, числовой || -2^63 .. 2^63 - 1 || Целочисленный тип повышенной точности
|-
| double || Вещественный, числовой || -1.8e+308 .. 1.8e+308 || Базовый вещественный тип
|-
| string || Строковый || 0 .. 32767 символов || Текст, чувствителен к регистру
Из значений в строковом типе нужно перед сохранением события удалять символ \x1
|}

===Создание новых типов===
<code>get("create_type({$type_name},{$type_id},{$type_description})")</code>
<br>
создает тип с именем <code>$type_name</code> (строка до 256 символов из букв
латинского алфавита, цифр и знаков подчеркивания, не начинающаяся с цифры),
идентификатором <code>$type_id</code> - числом до от 1 до 32767, и описанием
<code>$type_description</code>. <code>$type_description</code> имеет вид
"$field_description_1;$field_description_2;...;$field_description_n",
где <code>$field_description_i</code> - cтрока вида
"$field_name:$field_type". $field_type - один из поддерживаемых типов
"int", "long", "string" или "double", $field_name - имя поля (опять же
строка до 256 символов из букв английского алфавита, цифр и знаков
подчеркивания). Возвращает "OK", если все прошло успешно. В противном случае
возвращает сообщение об ошибке в читабельном виде.

===Добавление новых полей в существующий тип===
<code>get("add_field({$type_name},{$field_description})")</code>
<br>
Добавляет в тип с именем <code>$type_name</code> новое поле с описанием
<code>$field_description</code>, заданным в том же виде, что и в предыдущем
запросе.

===Добавление события===
<code>set("add_event([{$type_name}|{$type_id}],{$uid},{$ip},{$ua_hash},{$peer_id})", "{$desc}")</code>
<br>
$desc - описание события в виде
"{$field_name_1}:{$field_value_1}\x1{$field_name_2}:{$field_value_2}\x1...x1{$field_name_k}:{$field_value_k}".
$field_name_i - название поля, $field_value_i - значение соответствующего поля.
Любое из необязательных полей может отсутствовать в описании события.

===Поиск===
Выборка производится, ввиду ограничений протокола memcached, при помощи
следующей пары запросов:
<br>
<code>set("select{$random_tag}", $query)</code>
<br>
<code>get("select{$random_tag}")</code>, где $random_tag - случайное число
<br>
от 1 до 2000000000, описание $query будет дано ниже.

В случае необходимости сделать multiget есть альтернативный вариант:
<br>
<code>get("{$query}")</code>,
<br>
при использовании которого запрос должен быть короче 1000 символов и не должен
содержать символов с кодами не более 32. Все пробелы в запросе должны быть
заменены на символ 0xa0.

Запросы к движку чувствительны к регистру.

$query - строка следующего вида:
"SELECT[ DEFAULT][ LENGTH][ DISTINCT] (* | $return_field_1 [, $return_field_2 ...]) FROM ($type_name|[$type_name,]main_field_name=$field_value|*) WHERE $where_condition[,$agregate_where_condition] [LIMIT $limit_desc][ ORDER BY $agregate_alias[,(ASC|DESC)]]"
<br>
Модификатор DEFAULT означает, что в случае отсутствия поля, вместо него будет
использовано значение по умолчанию (0 для числовых типов и "" для
строкового). Если данный модификатор не указан, то объекты, в которых
отсутствуют поля, упомянутые в части SELECT либо в
<code>$where_condition</code>, не смогут быть возвращены.
<br>
Модификатор DISTINCT означает, что одинаковая строка не будет возвращена дважды.
<br>
Модификатор LENGTH означает, что будет возвращён лишь размер результата в виде,
описанном ниже.
<br>
Символ '*' в поле SELECT обозначает, что необходимо вернуть все поля.
<br>
Строка '*t' в поле SELECT обозначает, что необходимо вернуть все поля, при этом
необходимо выдать текстовое название типа события вместо числового.
<br>
<code>$return_field_i</code> - одно из выражений вида
<br>
<code>$field_name_i</code>, <code>[$expr_i]</code>,
<br>
<code>FUNС($field_name_i)</code> или <code>FUNС([$expr_i])</code>, где
<br>
<code>FUNC</code> - название агрегатной функции (одно из SUM, COUNT, MIN, MAX),
<br>
<code>$field_name_i</code> - название поля, к которому эту функцию необходимо
применить или * (только для COUNT).
<br>
<code>$expr_i</code> - произвольное арифметическое выражение, зависящее от
полей объекта. Также возвращаемому полю можно задавать alias (имя, под
которым это поле будет возвращено). Это делается посредством конструкции
<br>
<code>$return_field_i AS $alias_name_i</code>. alias для агрегатных функций
можно использовать в выражении $agregate_where_condition как имя поля.
<br>
<code>$type_name</code> - имя типа, среди объектов которого необходимо сделать
выборку.
<br>
<code>main_field_name</code> - имя одного из обязательных полей (type, ip,
uid), по которому производится выборка.
<br>
<code>$field_value</code> - значение соответствующего поля.
<br>
<code>$where_condition</code> - условие, которое должно быть выполнено для
каждой возвращаемой строки.
<br>
<code>$agregate_where_condition</code> - условие, которое должно быть выполнено
для каждой возвращаемой строки, накладываемое на значения агрегатных функций.
<br>
<code>$limit_desc</code> - описание лимита на возвращаемые данные, имеющее
формат <code>(T$time | [T$time,][$offset,]$row_count)</code>
<br>
<code>$row_count</code> - максимальное количество объектов в ответе.
По умолчанию равно 100000 и не может быть больше этого значения.
<br>
<code>$offset</code> - количество объектов, которые необходимо пропустить
при выводе.
<br>
<code>$time</code> - отсечение по времени, в которое произошло событие. Если
<br>
<code>$time >= 0</code>, то будут выданы события, произошедшие после времени
<br>
<code>$time</code>, если же <code>$time < 0</code>, то за последние
<br>
<code>-$time</code> секунд,
<br>
<code>$agregate_alias</code> - алиас на значение агрегатной функции, по
которому будут отсортированы объекты при выдаче. По умолчанию, сортировка
происходит после применения лимита по времени, до применения лимита по
количеству и в возрастающем порядке, как и при указании спецификатора
<code>ASC</code>. Для сортировки в убывающем порядке используется
спецификатор <code>DESC</code>. При равенстве соответствующих агрегатных
функций объекты сортируются в обратном хронологическом порядке. Использовать
поле <code>ORDER BY</code> можно только, если указан <code>LIMIT</code>.

В <code>$where_condition</code> и других условиях и выражениях можно
использовать скобки, а также все функции и операторы поддерживаемые
logs-engine. Приоритеты операторов задаются стандартным образом (то есть
как в C). Список поддерживаемых функций и операторов приведён в
[[KittenDB_Logs_Operators.wiki|KittenDB Logs Operators]].

В запросах строковые константы заключаются в одинарные кавычки, для
вещественных констант нельзя использовать экспоненциальную форму записи. В
случае, если выборка ведётся не в пределах конкретного типа (а, например, по
id пользователя и тип не указан), то в <code>$where_condition</code> и
<code>$return_field_i</code> нельзя использовать названия полей, отличные от
обязательных.

Результат возвращается в обратном хронологическом порядке (если не указано
обратное в поле <code>ORDER BY</code>) в формате JSON в виде массива объектов.
В случае наличия логической/синтаксической ошибки в запросе возвращается массив
с единственным объектом и с единственным полем <code>error</code>, в значении
которого содержится описание ошибки.

Если запрошена только длина ответа, то возвращается массив с единственным
объектом и с единственным полем <code>length</code>, в значении которого
содержится искомое число.

===Дополнительный функционал===

<code>get("types")</code> - получение списка добавленных типов в понятном виде.
<br>
<code>get("type_size[{$type}]")</code> - получение фактического расхода
оперативной памяти на объекты типа $type. Если $type не указан, то
возвращается информация про все типы.
<br>
<code>get("time")</code> - получение timestamp самого старого события,
хранящегося в движке.
<br>
<code>get("history[$limit]")</code> - получение текстов последних
$limit &lt;= 1000 запросов SELECT. Если $limit не указан, то возвращаются
последние 1000 запросов.

==="Покраска" индексных полей===
Каждому значению каждого индексного поля можно сопоставить произвольное
32-битное число ("цвет"), которое впоследствии можно использовать в запросах.
По умолчанию, "цвет" каждого значения равен 0. Так как каждому значению можно
сопоставить не более одного числа, то использовать это число нужно с
фиксированной, предопределённой и где-либо задокументированной целью.
Ввиду потенциально большого объёма хранимой информации не следует
злоупотреблять данной возможностью.

<code>get("change_color{$field_num},{$field_value},{$and_mask},{$xor_mask}[#{$cnt}])")</code>
<br>
Применяет к текущему "цвету" значений с <code>$field_value</code> по
<code>$field_value + $cnt - 1</code> (<code>$cnt</code> по умолчанию равно 1,
не более 65536) обязательного поля с физическим номером
<code>$field_num</code> последовательно <code>$and_mask</code> и
<code>$xor_mask</code> при помощи соответствующих побитовых операций.
В частности, если <code>$and_mask == 0</code>, то "цвет" будет заменён
на <code>$xor_mask</code>. Физические номера обязательных полей начинаются
с нуля и возрастают на 1 после 32-битного поля и на 2 после 64-битного поля.
Например, в основном кластере номер поля some_long_field равен 3.

<code>get("color{$field_num},{$field_value}")</code>
<br>
Возвращает "цвет" поля с физическим номером <code>$field_num</code> и
значением <code>$field_value</code>.
