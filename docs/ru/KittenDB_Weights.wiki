Weights-engine предназначен для хранения, обновления и отправки обновлений о "векторе весов" пользователей или каких-либо иных объектов. Например, он может собирать информацию о том, насколько пользователя интересует спорт, машины или смартфоны, что затем может быть использовано для показа рекламы или рекомендации новостей.

Основная сущность -- ''вектор весов'', идентифицируемый ненулевым 32-битным числом <tt>vector_id</tt> (например, идентификатором пользователя). Вектор весов состоит из не более чем 256 вещественных чисел ("координат") от -1 до 1, при этом хранятся только те из них, что не равны нулю. (Например, могут храниться только первые 32K координат для минимального подходящего K в виде односвязного списка из структур по 32 координаты.)

Координаты нумеруются числами от 1 до 255 (<tt>coord_id</tt>). В первоначальном варианте можно игнорировать coord_id > 31.

Основное действие -- добавить к координате указанного вектора ненулевое вещественное число. При этом передаются vector_id, coord_id и increment, причём increment в виде целого числа (нужный инкремент, умноженный на 2^30). Если вектора или координаты ещё не существует, они создаются и инициализируются нулём перед выполнением операции. Кроме того, есть операция получения целого вектора или только нескольких нужных координат. Возвращаются только ненулевые координаты, также в виде значения, домноженного на 2^30 и округлённого до ближайшего целого.

Для того, чтобы числа оставались в диапазоне -1..1, вместо сложения для изменения значения используется операция
<blockquote><tt>x # y := (x + y) / (1 + xy)</tt></blockquote>
Несложно видеть, что если -1 &lt; x, y &lt; 1, то и -1 &lt; x # y &lt; 1, и что операция # ассоциативна, коммутативна и x#0=x. Более того, если x и y близки к нулю, то x # y очень близко к x + y.

При желании эту формулу можно интерпретировать как формулу сложения скоростей в релятивистской механике, или же как формулу гиперболического тангенса суммы: 
<blockquote><tt>th(a+b) = th(a) # th(b)</tt></blockquote>
Поскольку гиперболический тангенс биективно отображает все вещественные числа на открытый интервал (-1,1), это доказывает ассоциативность и коммутативность операции #, а также показывает, каким образом можно быстро вычислять многократное применение такой операции с одним и тем же "инкрементом" y.

Кроме того, есть глобальный "период полураспада" T, и когда никто не изменяет компоненты вектора, они на самом деле постепенно "исчезают" по экспоненциальному закону: v -> v * exp(-t/T), где t = интервал времени.

Weights-engine поддерживает только RPC-протокол; конкретные запросы будут описаны далее на языке TL.

Важным функционалом является возможность подписки по RPC-протоколу на одного или на набор пользователей (вернее, идентификаторов векторов), выбираемых с помощью остатка по передаемому модулю. После получения запроса на подписку с указанием выбранного множества векторов и того, является ли эта подписка новой (т.е. есть ли у подписчика хоть какие-то данные, возможно, устаревшие, или нет), weights-engine начинает постепенно отправлять подписчику заказанные обновления, группируя обновления нескольких векторов в одно сообщение. При этом передаются только некоторые координаты; остальные координаты могут остаться неизменными или обнулиться.

Подписчику не отправляется слишком много данных сразу; они аккуратно дозируются. Например, ему могут отсылать раз в 37 миллисекунд обновление, размер которого (т.е. количество векторов) определяется по пуассоновскому распределению.

Вероятно, имеет смысл отправить подписчику период полураспада, чтобы он мог сам обновлять незатрагиваемые компоненты векторов при необходимости без получения явных обновлений.
