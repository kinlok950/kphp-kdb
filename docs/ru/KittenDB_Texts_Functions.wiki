=== Получение сообщения по local_id ===

<code>get("message{$uid}_{$local_id}")</code>
<br>
<code>get("message{$uid}_{$local_id}#$mode")</code>
<br>
<code>get("message{$uid}_{$local_id}#$mode,$max_len")</code>

Получает сообщение пользователя (или "ящика", или "списка") $uid с локальным номером $local_id. Существует возможность передать дополнительные целочисленные параметры $mode и $max_len.
<br>
Возвращает строку вида
<br>
<code>$flags,$date,$peer_id[$extra_fields]\t$subject\t$message</code>
<br>
или
<br>
<code>$flags,$date,$peer_id[$extra_fields]\t$text</code>
<br>
если для данного типа текстов не поддерживается $subject. Наличие дополнительных полей $extra_fields зависит от флагов, переданных в $mode; это целочисленные поля, разделяемые запятыми.

Поле $max_len есть максимальное количество возвращаемых байтов сообщения. Если оно нулевое, текст сообщения вообще не возвращается. Биты $mode приводят к добавлению в $extra_fields следующих полей:

* +1  возвращает <code>global_id</code>
* +2  возвращает <code>legacy_id</code>
* +4  возвращает <code>peer_msg_id</code>
* +8 возвращает текст сообщения с кладжами (в $extra_fields добавляется длина возвращенных кладжей - если при этом общая длина кладжей больше $max_len, то пишется $max_len)
* +16 не возвращает текст сообщения
* +24 возвращает только кладжи (в $extra_fields добавляется длина возвращенных кладжей, аналогично варианту +8)
* +32 зарезервировано (возвращать <tt>flags</tt>)
* +64 зарезервировано (возвращать <tt>date</tt>)
* +128 зарезервировано (возвращать <tt>peer_id</tt>)
* +256 возвращает <code>ip</code>
* +512 возвращает <code>port</code>
* +1024 возвращает <code>front</code>
* +2048 возвращает <code>ua_hash</code>
* +2<sup>16+k</sup>, k=0..7 возвращает дополнительные 32-битные поля <tt>extra0</tt>..<tt>extra7</tt> в виде 32-битных целых со знаком, если соответствующего поля нет, возвращается 0.
* +2<sup>16+k</sup>, k=8..11 возвращает дополнительные 64-битные поля <tt>Extra8</tt>..<tt>Extra11</tt>.

=== Получение local_id сообщения по legacy_id ===
<code>get("convert_legacy_id{$uid}_{$legacy_id}")</code>
<br>
Возвращает <code>local_id</code> сообщения из ящика пользователя <code>uid</code> с переданным <code>legacy_id</code>. В некоторых ситуациях может вернуть local_id уже удаленного сообщения с нужным legacy_id.

=== Получение номеров сообщений из истории переписки ===
<code>get("peermsglist$uid_$peer#$from,$to")</code>
<br>
Возвращает local_id сообщений, входящих в историю переписки $uid c $peer. Возвращаются сообщения с $from по $to, нумерация - с единицы (1 = самое старое). Отрицательные числа означают, что соответствующее сообщение отсчитывается с конца списка (-1 = самое новое, -2 = предпоследнее и т.п.).
<br>
Если сообщение $to предшествует сообщению $from, то они возвращаются в обратном порядке.
<br>
Таким образом, "#0,0" не вернет ни одного сообщения, а "#-1,1" вернет все в обратном порядке.

Результат - строка, состоящая из десятичных записей чисел, разделенных запятыми. Первое число - общее количество сообщений в запрошенном списке (таким образом, <code>get("peermsglist$uid_$peer#0,0")</code> вернет количество сообщений). Далее следуют local_id сообщений.

=== Получение позиции сообщения из истории переписки ===
<code>get("peermsglistpos$uid_$peer:$local_id")</code>
<br>
Возвращает количество сообщений, входящих в историю переписки $uid с $peer, с local_id, не превосходящим переданного.

=== Получение последних сообщений из объединения историй переписки ===
<code>set("temp$tag", "$peer1,$peer2,...,$peerN");</code>
<br>
<code>get("joinpeermsg$uid_$tag,$flags#$limit");</code>
<br>
Здесь $tag -- случайное число от 1 до 10<sup>9</sup>, идентификатор списка. Второй запрос возвращает $local_id последних $limit записей из объединения историй переписки $uid с $peer1, $peer2, ..., $peerN, в порядке убывания. Перед этим списком дописывается общее количество сообщений в объединённом списке. Значение $flags пока всегда 0; в будущем может появиться флаг +128 (возвращать peer_id), а отрицательный $limit будет означать, что надо возвращать ответ в порядке возрастания.

=== Получение последних сообщений для каждого peer_id ===
<code>get("topmsglist$uid#$from,$to")</code>
<br>
Вычисляет для каждого peer_id local_id последнего сообщения в истории переписки с peer_id, после чего полученный список пар (local_id,peer_id) сортируется по local_id.

Затем возвращаются элементы полученного массива с $from по $to, нумерация - с единицы (1 = самое старое). Отрицательные числа означают, что соответствующее сообщение отсчитывается с конца списка (-1 = самое новое, -2 = предпоследнее и т.п.).
<br>
Если сообщение $to предшествует сообщению $from, то они возвращаются в обратном порядке.
<br>
Таким образом, "#0,0" не вернет ни одного сообщения, а "#-1,1" вернет все в обратном порядке.

Результат - строка, состоящая из десятичных записей чисел, разделенных запятыми. Первое число - общее количество элементов в общем списке пар (таким образом, <code>get("topmsglist$uid#0,0")</code> вернет количество различных peer_id). Далее следуют local_id сообщений и соответствующие peer_id.

=== Получение номеров сообщений из подсписка сообщений ===
<code>get("sublist{$uid}_$and_mask:$xor_mask#$from,$to")</code>
<br>
Получает список local_id сообщений пользователя $uid, характеризуемых условием <code>((FLAGS ^ $xor_mask) & $and_mask) == 0</code>, или, что почти одно и то же, <code>FLAGS & $and_mask == $xor_mask</code>. Параметры $from и $to, как и формат возвращаемой строки, такие же, как и выше.
<br>
Если переданный подсписок не поддерживается, возвращается строка "NOT_SUPPORTED".

=== Получение номеров и дополнительной информации для сообщений из подсписка сообщений ===
<code>get("sublistx{$uid}_{$mode},$and_mask:$xor_mask#$from,$to")</code>
<br>
Получает список local_id и дополнительных параметров сообщений пользователя $uid, характеризуемых условием <code>((FLAGS ^ $xor_mask) & $and_mask) == 0</code>, или, что почти одно и то же, <code>FLAGS & $and_mask == $xor_mask</code>. Параметры $from и $to, как и формат возвращаемой строки, такие же, как и выше (возвращается общее количество и (1+K)N целых чисел,  где K -- количество заказанных дополнительных параметров).
<br>
Параметр $mode выбирает, какие дополнительные параметры надо возвращать.
* +32 возвращает <tt>flags</tt>
* +64 возвращает <tt>date</tt>
* +128 возвращает <tt>peer_id</tt>

Всегда возвращается local_id, за ним выбранные параметры в порядке flags, date, global_id, legacy_id, peer_msg_id, extra.

Если переданный подсписок не поддерживается, возвращается строка "NOT_SUPPORTED".

=== Получение позиции сообщения из подсписка ===
<code>get("sublistpos{$uid}_$and_mask:$xor_mask,$local_id")</code>

Возвращает количество сообщений, входящих в подсписок сообщений пользователя $uid, характеризуемых условием <code>((FLAGS ^ $xor_mask) & $and_mask) == 0</code>, с local_id, не превосходящим данного.

Если переданный подсписок не поддерживается, возвращается строка "NOT_SUPPORTED".

=== Получение списка типов поддерживаемых подсписков ===
<code>get("sublists_types")</code>

Возвращает строку с описанием поддерживаемых типов подсписков, перечисленных через запятую. Каждый тип подсписка представлен строкой "$and_mask:$xor_mask".

=== Получение подсписка, из которого строится история переписки ===
<code>get("peermsg_type")</code>

Возвращает строку вида "$and_mask:$xor_mask", описывающую, сообщения с какими флагами участвуют в историях переписки.

=== Добавление нового сообщения ===
<code>set("newmsg$uid#$random_tag", "$flags,$peer_id,$peer_msg_id,$legacy_id\n$subject\t$message")</code>
<br>
<code>set("newmsg$uid,$extra_mask#$random_tag", "$flags,$peer_id,$peer_msg_id,$legacy_id,$extra_fields\n$subject\t$message")</code>
<br>
Добавляет новое сообщение в ящик $uid. В первой строке значения передаются флаги и основные поля, все - десятичные числа. Поля, начиная с $peer_msg_id, не являются обязательными. Во второй строке начинается само сообщение; тема сообщения (если нужна ее поддержка) отделяется табуляцией.

Во второй форме $extra_fields содержит 32-битные поля <tt>extra0</tt>..<tt>extra7</tt>, наличие которых управляется битами 0-7 в поле $extra_mask, и затем 64-битные поля <tt>Extra8</tt>..<tt>Extra11</tt>, наличие которых управляется битами 8-11 в поле $extra_mask.

Необязательное положительное 32-битное поле $random_tag нужно для того, чтобы можно было получить local_id созданного сообщения.

=== Получение local_id cозданного сообщения ===
<code>get("newmsgid$uid#$random_tag")</code>
<br>
Возвращает local_id недавно созданного сообщения с переданным $random_tag. Желательно запускать сразу же после соответствующего set.

=== Удаление сообщения ===
<code>delete("message{$uid}_{$local_id}")</code>
<br>
Удаляет сообщение с заданным $local_id.

=== Удаление сообщений с local_id, меньших заданного ===
<code>delete("first_messages{$uid}_{$min_local_id}")</code>
<br>
Удаляет все сообщения с local_id &lt; min_local_id.

=== Получение флагов сообщения ===
<code>get("flags{$uid}_{$local_id}")</code>
<br>
Получает флаги сообщения. Если сообщения нет, возвращается <code>false</code>.

=== Изменение флагов сообщения ===
<code>set("flags{$uid}_{$local_id}", $new_flags)</code>
<br>
<code>increment("flags{$uid}_{$local_id}", $incr_mask)</code>
<br>
<code>decrement("flags{$uid}_{$local_id}", $decr_mask)</code>
<br>
Изменяет флаги указанного сообщения. Формы increment/decrement осуществляют логическое, а не арифметическое сложение или вычитание переданной маски из текущих флагов, и возвращают итоговое значение, или 2^32-1, если для получения точного значения флагов надо обращаться к диску. Более того, может вернуться некоторое значение флагов для удаленного или несуществующего сообщения.

=== Получение дополнительного поля сообщения ===
<code>get("extra{$uid}_{$local_id}:$k")</code>
<br>
<code>get("Extra{$uid}_{$local_id}:$k")</code>
<br>
Возвращает значение дополнительного 32-битного поля <tt>extra$k</tt>, где ''k'' от 0 до 7, либо 64-битного поля <tt>Extra$k</tt>, где ''k'' от 8 до 11. Все возвращаемые значения - знаковые. Если поле отсутствует, возвращается 0.

=== Изменение дополнительного поля сообщения ===
<code>set("extra{$uid}_{$local_id}:$k", $new_value)</code>
<br>
<code>increment("extra{$uid}_{$local_id}:$k", $incr_value)</code>
<br>
<code>decrement("extra{$uid}_{$local_id}:$k", $decr_value)</code>
<br>
<code>set("Extra{$uid}_{$local_id}:$k", $new_value)</code>
<br>
<code>increment("Extra{$uid}_{$local_id}:$k", $incr_value)</code>
<br>
<code>decrement("Extra{$uid}_{$local_id}:$k", $decr_value)</code>
<br>
Изменяет значение 32-битного или 64-битного дополнительного поля указанного сообщения. Формы increment/decrement осуществляют арифметическое, а не логическое сложение или вычитание, и возвращают итоговое значение, или -2<sup>31</sup> (-2<sup>63</sup> для Extra), если для получения точного значения надо обращаться к диску. Более того, может вернуться некоторое значение для удаленного или несуществующего сообщения.
<br>
В отличие от настоящего memcached, при изменении ранее отсутствовавшего поля оно автоматически создается со значением 0, и отрицательные значения переменных допускаются.

=== Изменение битовой маски наличия дополнительных полей ===
<code>set("ExtraFields{$new_bitmask}", $new_bitmask ^ 0xbeda)</code>

=== Получение битовой маски наличия дополнительных полей ===
<code>get("ExtraFields")</code>
<br>
Возвращает $write_extra_mask:$read_extra_mask:$index_extra_mask.

=== Выгрузка из памяти данных пользователя ===
<code>delete("userdata$uid")</code>

=== Получение информации о наличии в памяти данных пользователя ===
<code>get("userdata$uid")</code>

=== Загрузка данных пользователя ===
<code>set("userdata$uid", $mode)</code>
<br>
Здесь $mode=1 означает немедленную загрузку, $mode=2 - отложенную (асинхронную).

=== Изменение текста существующего сообщения ===
<code>replace("message_text{$uid}_{$local_id}", $new_text)</code>
<br>
Изменяет текст сообщения на переданный. При этом сообщение должно было существовать ранее.

== Поиск и работа с историей ==
См. [[KittenDB_Texts_Extra.wiki|KittenDB Texts Extra]].
